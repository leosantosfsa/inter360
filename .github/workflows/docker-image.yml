# Nome do workflow que aparecerá na aba "Actions"
name: backend

# Define o gatilho para a execução do workflow
on:
  push:
    branches: [ "main" ] # Aciona em pushes para a branch 'main'
  # Também é uma boa prática acionar em novas releases
  # release:
  #   types: [ created ]

# Variáveis de ambiente para todo o workflow
env:
  REGISTRY: ghcr.io
  # O nome da imagem será o nome do repositório em letras minúsculas
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    # O sistema operacional do runner
    runs-on: ubuntu-latest
    
    # Permissões necessárias para o GITHUB_TOKEN
    # contents: read -> para fazer o checkout do código
    # packages: write -> para fazer o push da imagem para o GHCR
    permissions:
      contents: read
      packages: write

    steps:
      # 1. Faz o checkout do código do repositório
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Faz o login no GitHub Container Registry (ghcr.io)
      # Usa o GITHUB_TOKEN para autenticação segura e automática
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 3. Extrai metadados (tags e labels) para a imagem Docker
      # Esta ação cria tags inteligentes, como 'latest', 'sha-<hash_do_commit>', etc.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      # 4. Constrói e publica a imagem Docker
      # Usa o cache do build para acelerar execuções futuras
      - name: backend
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
